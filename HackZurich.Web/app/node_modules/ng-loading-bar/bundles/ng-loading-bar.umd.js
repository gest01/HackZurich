(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/http'), require('rxjs/Subject'), require('rxjs/add/operator/share')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/http', 'rxjs/Subject', 'rxjs/add/operator/share'], factory) :
	(factory((global['ng-loading-bar'] = {}),global.ng.core,global.ng.http,global.Rx));
}(this, (function (exports,_angular_core,_angular_http,rxjs_Subject) { 'use strict';

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var NgLoadingBarHttp = (function (_super) {
    __extends(NgLoadingBarHttp, _super);
    function NgLoadingBarHttp() {
        var _this = _super.apply(this, arguments) || this;
        _this.pending = new rxjs_Subject.Subject();
        _this._pendingRequests = 0;
        return _this;
    }
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    NgLoadingBarHttp.prototype.request = function (url, options) {
        var _this = this;
        var /** @type {?} */ response = _super.prototype.request.call(this, url, options).share();
        if (options && options.ignoreLoadingBar === true) {
            return response;
        }
        this.requestStarted();
        response.subscribe(function (x) { }, function (err) { return _this.requestEnded(); }, function () { return _this.requestEnded(); });
        return response;
    };
    /**
     * @return {?}
     */
    NgLoadingBarHttp.prototype.requestStarted = function () {
        this.pending.next({
            started: this._pendingRequests === 0,
            pendingRequests: ++this._pendingRequests,
        });
    };
    /**
     * @return {?}
     */
    NgLoadingBarHttp.prototype.requestEnded = function () {
        this.pending.next({
            completed: this._pendingRequests === 1,
            pendingRequests: --this._pendingRequests,
        });
    };
    return NgLoadingBarHttp;
}(_angular_http.Http));
NgLoadingBarHttp.decorators = [
    { type: _angular_core.Injectable },
];
/**
 * @nocollapse
 */
NgLoadingBarHttp.ctorParameters = function () { return []; };
var NgLoadingBarComponent = (function () {
    /**
     * @param {?} _renderer
     * @param {?} http
     */
    function NgLoadingBarComponent(_renderer, http) {
        var _this = this;
        this._renderer = _renderer;
        this.includeSpinner = true;
        this._autoIncrement = true;
        this._includeBar = true;
        this._latencyThreshold = 10;
        this._startSize = 0.02;
        this._started = false;
        this._status = 0;
        if (http instanceof NgLoadingBarHttp) {
            http.pending.subscribe(function (progress) {
                if (progress.started)
                    _this.start();
                if (progress.completed)
                    _this.complete();
            });
        }
    }
    /**
     * @return {?}
     */
    NgLoadingBarComponent.prototype.ngAfterViewInit = function () {
        this.hide(this._loadingBarContainer);
        this.hide(this._spinner);
    };
    /**
     * Inserts the loading bar element into the dom, and sets it to 2%
     * @return {?}
     */
    NgLoadingBarComponent.prototype.start = function () {
        var _this = this;
        this._startTimeout = setTimeout(function () {
            clearTimeout(_this._completeTimeout);
            // do not continually broadcast the started event:
            if (_this._started) {
                return;
            }
            _this._started = true;
            _this._status = 0;
            if (_this._includeBar) {
                _this.show(_this._loadingBarContainer);
            }
            if (_this.includeSpinner) {
                _this.show(_this._spinner);
            }
            _this.set(_this._startSize);
        }, this._latencyThreshold);
    };
    /**
     * Set the loading bar's width to a certain percent.
     *
     * @param {?} n any value between 0 and 1
     * @return {?}
     */
    NgLoadingBarComponent.prototype.set = function (n) {
        var _this = this;
        if (!this._started) {
            return;
        }
        var /** @type {?} */ pct = (n * 100) + '%';
        this.setElementStyle(this._loadingBar, 'width', pct);
        this._status = n;
        // increment loadingbar to give the illusion that there is always
        // progress but make sure to cancel the previous timeouts so we don't
        // have multiple incs running at the same time.
        if (this._autoIncrement) {
            clearTimeout(this._incTimeout);
            this._incTimeout = setTimeout(function () {
                _this.inc();
            }, 250);
        }
    };
    /**
     * @return {?}
     */
    NgLoadingBarComponent.prototype.complete = function () {
        var _this = this;
        setTimeout(function () {
            _this.set(1);
            clearTimeout(_this._completeTimeout);
            clearTimeout(_this._startTimeout);
            // Attempt to aggregate any start/complete calls within 500ms:
            _this._completeTimeout = setTimeout(function () {
                _this._started = false;
                _this.hide(_this._loadingBarContainer);
                _this.hide(_this._spinner);
            }, 500);
        }, this._latencyThreshold);
    };
    /**
     * Increments the loading bar by a random amount
     * but slows down as it progresses
     * @return {?}
     */
    NgLoadingBarComponent.prototype.inc = function () {
        if (this._status >= 1) {
            return;
        }
        var /** @type {?} */ rnd = 0;
        var /** @type {?} */ stat = this._status;
        if (stat >= 0 && stat < 0.25) {
            // Start out between 3 - 6% increments
            rnd = (Math.random() * (5 - 3 + 1) + 3) / 100;
        }
        else if (stat >= 0.25 && stat < 0.65) {
            // increment between 0 - 3%
            rnd = (Math.random() * 3) / 100;
        }
        else if (stat >= 0.65 && stat < 0.9) {
            // increment between 0 - 2%
            rnd = (Math.random() * 2) / 100;
        }
        else if (stat >= 0.9 && stat < 0.99) {
            // finally, increment it .5 %
            rnd = 0.005;
        }
        else {
            // after 99%, don't increment:
            rnd = 0;
        }
        var /** @type {?} */ pct = this._status + rnd;
        this.set(pct);
    };
    /**
     * @param {?} el
     * @return {?}
     */
    NgLoadingBarComponent.prototype.show = function (el) {
        this.setElementStyle(el, 'display', 'block');
    };
    /**
     * @param {?} el
     * @return {?}
     */
    NgLoadingBarComponent.prototype.hide = function (el) {
        this.setElementStyle(el, 'display', 'none');
    };
    /**
     * @param {?} el
     * @param {?} styleName
     * @param {?} styleValue
     * @return {?}
     */
    NgLoadingBarComponent.prototype.setElementStyle = function (el, styleName, styleValue) {
        this._renderer.setElementStyle(el.nativeElement, styleName, styleValue);
    };
    return NgLoadingBarComponent;
}());
NgLoadingBarComponent.decorators = [
    { type: _angular_core.Component, args: [{
                selector: 'ng-loading-bar',
                template: "\n        <div id=\"loading-bar-spinner\" #loadingBarSpinner><div class=\"spinner-icon\"></div></div>\n        <div id=\"loading-bar\" #loadingBarContainer><div class=\"bar\" #loadingBar><div class=\"peg\"></div></div></div>\n    ",
            },] },
];
/**
 * @nocollapse
 */
NgLoadingBarComponent.ctorParameters = function () { return [
    { type: _angular_core.Renderer, },
    { type: NgLoadingBarHttp, decorators: [{ type: _angular_core.Inject, args: [_angular_http.Http,] },] },
]; };
NgLoadingBarComponent.propDecorators = {
    '_spinner': [{ type: _angular_core.ViewChild, args: ['loadingBarSpinner',] },],
    '_loadingBarContainer': [{ type: _angular_core.ViewChild, args: ['loadingBarContainer',] },],
    '_loadingBar': [{ type: _angular_core.ViewChild, args: ['loadingBar',] },],
    'includeSpinner': [{ type: _angular_core.Input },],
};
/**
 * @param {?} xhrBackend
 * @param {?} requestOptions
 * @return {?}
 */
function httpFactory(xhrBackend, requestOptions) {
    return new NgLoadingBarHttp(xhrBackend, requestOptions);
}
var NgLoadingBarModule = (function () {
    function NgLoadingBarModule() {
    }
    /**
     * @return {?}
     */
    NgLoadingBarModule.forRoot = function () {
        return {
            ngModule: NgLoadingBarModule,
            providers: [
                { provide: _angular_http.Http, useFactory: httpFactory, deps: [_angular_http.XHRBackend, _angular_http.RequestOptions] },
            ],
        };
    };
    return NgLoadingBarModule;
}());
NgLoadingBarModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                declarations: [
                    NgLoadingBarComponent,
                ],
                imports: [
                    _angular_http.HttpModule,
                ],
                exports: [
                    NgLoadingBarComponent,
                ],
            },] },
];
/**
 * @nocollapse
 */
NgLoadingBarModule.ctorParameters = function () { return []; };

exports.NgLoadingBarModule = NgLoadingBarModule;
exports.NgLoadingBarHttp = NgLoadingBarHttp;
exports.NgLoadingBarComponent = NgLoadingBarComponent;
exports.Éµa = httpFactory;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ng-loading-bar.umd.js.map
