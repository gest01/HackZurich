import { Component, Inject, Injectable, Input, NgModule, Renderer, ViewChild } from '@angular/core';
import { Http, HttpModule, RequestOptions, XHRBackend } from '@angular/http';
import { Subject } from 'rxjs/Subject';
import 'rxjs/add/operator/share';

class NgLoadingBarHttp extends Http {
    constructor() {
        super(...arguments);
        this.pending = new Subject();
        this._pendingRequests = 0;
    }
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    request(url, options) {
        const /** @type {?} */ response = super.request(url, options).share();
        if (options && options.ignoreLoadingBar === true) {
            return response;
        }
        this.requestStarted();
        response.subscribe((x) => { }, (err) => this.requestEnded(), () => this.requestEnded());
        return response;
    }
    /**
     * @return {?}
     */
    requestStarted() {
        this.pending.next({
            started: this._pendingRequests === 0,
            pendingRequests: ++this._pendingRequests,
        });
    }
    /**
     * @return {?}
     */
    requestEnded() {
        this.pending.next({
            completed: this._pendingRequests === 1,
            pendingRequests: --this._pendingRequests,
        });
    }
}
NgLoadingBarHttp.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
NgLoadingBarHttp.ctorParameters = () => [];

class NgLoadingBarComponent {
    /**
     * @param {?} _renderer
     * @param {?} http
     */
    constructor(_renderer, http) {
        this._renderer = _renderer;
        this.includeSpinner = true;
        this._autoIncrement = true;
        this._includeBar = true;
        this._latencyThreshold = 10;
        this._startSize = 0.02;
        this._started = false;
        this._status = 0;
        if (http instanceof NgLoadingBarHttp) {
            http.pending.subscribe((progress) => {
                if (progress.started)
                    this.start();
                if (progress.completed)
                    this.complete();
            });
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.hide(this._loadingBarContainer);
        this.hide(this._spinner);
    }
    /**
     * Inserts the loading bar element into the dom, and sets it to 2%
     * @return {?}
     */
    start() {
        this._startTimeout = setTimeout(() => {
            clearTimeout(this._completeTimeout);
            // do not continually broadcast the started event:
            if (this._started) {
                return;
            }
            this._started = true;
            this._status = 0;
            if (this._includeBar) {
                this.show(this._loadingBarContainer);
            }
            if (this.includeSpinner) {
                this.show(this._spinner);
            }
            this.set(this._startSize);
        }, this._latencyThreshold);
    }
    /**
     * Set the loading bar's width to a certain percent.
     *
     * @param {?} n any value between 0 and 1
     * @return {?}
     */
    set(n) {
        if (!this._started) {
            return;
        }
        const /** @type {?} */ pct = (n * 100) + '%';
        this.setElementStyle(this._loadingBar, 'width', pct);
        this._status = n;
        // increment loadingbar to give the illusion that there is always
        // progress but make sure to cancel the previous timeouts so we don't
        // have multiple incs running at the same time.
        if (this._autoIncrement) {
            clearTimeout(this._incTimeout);
            this._incTimeout = setTimeout(() => {
                this.inc();
            }, 250);
        }
    }
    /**
     * @return {?}
     */
    complete() {
        setTimeout(() => {
            this.set(1);
            clearTimeout(this._completeTimeout);
            clearTimeout(this._startTimeout);
            // Attempt to aggregate any start/complete calls within 500ms:
            this._completeTimeout = setTimeout(() => {
                this._started = false;
                this.hide(this._loadingBarContainer);
                this.hide(this._spinner);
            }, 500);
        }, this._latencyThreshold);
    }
    /**
     * Increments the loading bar by a random amount
     * but slows down as it progresses
     * @return {?}
     */
    inc() {
        if (this._status >= 1) {
            return;
        }
        let /** @type {?} */ rnd = 0;
        let /** @type {?} */ stat = this._status;
        if (stat >= 0 && stat < 0.25) {
            // Start out between 3 - 6% increments
            rnd = (Math.random() * (5 - 3 + 1) + 3) / 100;
        }
        else if (stat >= 0.25 && stat < 0.65) {
            // increment between 0 - 3%
            rnd = (Math.random() * 3) / 100;
        }
        else if (stat >= 0.65 && stat < 0.9) {
            // increment between 0 - 2%
            rnd = (Math.random() * 2) / 100;
        }
        else if (stat >= 0.9 && stat < 0.99) {
            // finally, increment it .5 %
            rnd = 0.005;
        }
        else {
            // after 99%, don't increment:
            rnd = 0;
        }
        let /** @type {?} */ pct = this._status + rnd;
        this.set(pct);
    }
    /**
     * @param {?} el
     * @return {?}
     */
    show(el) {
        this.setElementStyle(el, 'display', 'block');
    }
    /**
     * @param {?} el
     * @return {?}
     */
    hide(el) {
        this.setElementStyle(el, 'display', 'none');
    }
    /**
     * @param {?} el
     * @param {?} styleName
     * @param {?} styleValue
     * @return {?}
     */
    setElementStyle(el, styleName, styleValue) {
        this._renderer.setElementStyle(el.nativeElement, styleName, styleValue);
    }
}
NgLoadingBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-loading-bar',
                template: `
        <div id="loading-bar-spinner" #loadingBarSpinner><div class="spinner-icon"></div></div>
        <div id="loading-bar" #loadingBarContainer><div class="bar" #loadingBar><div class="peg"></div></div></div>
    `,
            },] },
];
/**
 * @nocollapse
 */
NgLoadingBarComponent.ctorParameters = () => [
    { type: Renderer, },
    { type: NgLoadingBarHttp, decorators: [{ type: Inject, args: [Http,] },] },
];
NgLoadingBarComponent.propDecorators = {
    '_spinner': [{ type: ViewChild, args: ['loadingBarSpinner',] },],
    '_loadingBarContainer': [{ type: ViewChild, args: ['loadingBarContainer',] },],
    '_loadingBar': [{ type: ViewChild, args: ['loadingBar',] },],
    'includeSpinner': [{ type: Input },],
};

/**
 * @param {?} xhrBackend
 * @param {?} requestOptions
 * @return {?}
 */
function httpFactory(xhrBackend, requestOptions) {
    return new NgLoadingBarHttp(xhrBackend, requestOptions);
}
class NgLoadingBarModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgLoadingBarModule,
            providers: [
                { provide: Http, useFactory: httpFactory, deps: [XHRBackend, RequestOptions] },
            ],
        };
    }
}
NgLoadingBarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NgLoadingBarComponent,
                ],
                imports: [
                    HttpModule,
                ],
                exports: [
                    NgLoadingBarComponent,
                ],
            },] },
];
/**
 * @nocollapse
 */
NgLoadingBarModule.ctorParameters = () => [];

/**
 * Generated bundle index. Do not edit.
 */

export { NgLoadingBarModule, NgLoadingBarHttp, NgLoadingBarComponent, httpFactory as Éµa };
//# sourceMappingURL=ng-loading-bar.js.map
